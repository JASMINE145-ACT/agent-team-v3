1 # Agent Team version3 — 框架化改造计划
        2
        3 > 目标：把「ReAct 引擎 + 会话 + 流式」抽为不知业务的 **core**，
        4 > 把「工具 + Prompt 技能 + 业务知识」封装为可插拔的 **Extension**，
        5 > 借鉴 pi-mono 的 Registry + Extension 模式，以 Python 实现。
        6
        7 ---
        8
        9 ## 一、改造目标
       10
       11 | 目标 | 具体描述 |
       12 |------|----------|
       13 | 核心与业务解耦 | `CoreAgent` 不 import 任何业务模块；所有业务通过 Extension 注册 |
       14 | 工具注册化 | 消灭 150 行 `if/elif` 分发链，改为 `ToolRegistry` 查表分发 |
       15 | 钩子可用 | `on_before_prompt` / `on_after_tool` 真正被用起来（当前 `after_tool_call` 空置） |
       16 | 新业务 = 新 Extension | 另起一套 HR/客服 bot 只需实现 `AgentExtension`，不动 core |
       17 | 迁移零断点 | 每步完成后服务可正常启动，不出现"改到一半跑不了"的状态 |
       18
       19 ---
       20
       21 ## 二、架构蓝图
       22
       23 ### 改造前（混合态）
       24
       25 ```
       26 backend/agent/agent.py
       27 ├── _SKILL_* 常量        ← 业务
       28 ├── _build_system_prompt ← 业务
       29 ├── SingleAgent
       30 │   └── execute_react()  ← 核心（但耦合了 get_all_tools / execute_tool）
       31
       32 backend/agent/tools.py
       33 ├── EXTRA_TOOLS          ← 业务
       34 ├── execute_tool()       ← 150 行 if/elif 分发
       35 └── _tool_error 等辅助   ← 可复用工具
       36 ```
       37
       38 ### 改造后（三层）
       39
       40 ```
       41 backend/
       42 ├── core/                        ← 纯框架，零业务依赖
       43 │   ├── __init__.py
       44 │   ├── registry.py              ← ToolRegistry（查表分发）
       45 │   ├── extension.py             ← AgentExtension ABC + ExtensionContext
       46 │   ├── agent.py                 ← CoreAgent（接受 extensions）
       47 │   └── tool_utils.py            ← _tool_error / _validate_file_path
       48 │
       49 ├── plugins/                     ← 业务插件
       50 │   └── jagent/
       51 │       ├── __init__.py
       52 │       ├── extension.py         ← JAgentExtension（注册全部工具 + 技能 prompt）
       53 │       └── skills.py            ← _SKILL_* 常量（从 agent.py 平移）
       54 │
       55 ├── agent/                       ← 保留（薄封装，兼容现有 import）
       56 │   ├── agent.py                 ← from backend.core.agent import CoreAgent as SingleAgent
       57 │   ├── tools.py                 ← 已空，import 重定向
       58 │   └── session.py               ← 不动 ✅
       59 │
       60 ├── tools/                       ← 实现层，完全不动 ✅
       61 │   ├── inventory/
       62 │   ├── quotation/
       63 │   └── oos/
       64 │
       65 └── server/                      ← 网络层，最小改动
       66     ├── api/
       67     │   ├── app.py               ← 改为 create_app(extensions=[JAgentExtension()])
       68     │   └── routes.py            ← agent 从 app.state 取，不再模块级实例化
       69     └── gateway/
       70         └── handlers/chat.py     ← agent 从 app.state 取
       71 ```
       72
       73 ---
       74
       75 ## 三、新建文件（带完整代码）
       76
       77 ### 3.1 `backend/core/__init__.py`
       78
       79 ```python
       80 # 空文件，标记 package
       81 ```
       82
       83 ---
       84
       85 ### 3.2 `backend/core/registry.py`
       86
       87 ```python
       88 """ToolRegistry — 工具注册表，替代 if/elif 分发链。"""
       89 import json
       90 import logging
       91 from dataclasses import dataclass
       92 from typing import Any, Callable
       93
       94 logger = logging.getLogger(__name__)
       95
       96
       97 @dataclass
       98 class ToolEntry:
       99     definition: dict          # OpenAI function-calling 格式
      100     handler: Callable         # async (args: dict, ctx: dict) -> str
      101
      102
      103 class ToolRegistry:
      104     def __init__(self):
      105         self._tools: dict[str, ToolEntry] = {}
      106
      107     def register(self, definition: dict, handler: Callable) -> None:
      108         name = definition["function"]["name"]
      109         self._tools[name] = ToolEntry(definition, handler)
      110
      111     def get_definitions(self) -> list[dict]:
      112         return [e.definition for e in self._tools.values()]
      113
      114     async def execute(self, name: str, args: dict[str, Any], ctx: dict) -> str:
      115         entry = self._tools.get(name)
      116         if not entry:
      117             return json.dumps({"error": f"未知工具: {name}"}, ensure_ascii=False)
      118         try:
      119             return await entry.handler(args, ctx)
      120         except Exception as e:
      121             logger.exception("ToolRegistry 执行 %s 失败", name)
      122             return json.dumps({"error": str(e)}, ensure_ascii=False)
      123
      124     def has(self, name: str) -> bool:
      125         return name in self._tools
      126
      127     def names(self) -> list[str]:
      128         return list(self._tools.keys())
      129 ```
      130
      131 ---
      132
      133 ### 3.3 `backend/core/extension.py`
      134
      135 ```python
      136 """AgentExtension — 业务扩展接口（对标 pi-mono 的 Extension）。"""
      137 from __future__ import annotations
      138 from abc import ABC, abstractmethod
      139 from dataclasses import dataclass
      140 from typing import TYPE_CHECKING, Callable
      141
      142 if TYPE_CHECKING:
      143     from backend.core.registry import ToolRegistry
      144     from backend.agent.session import SessionStore
      145
      146
      147 @dataclass
      148 class ExtensionContext:
      149     """受控访问句柄，Extension 通过它注册工具，不直接持有 agent。"""
      150     registry: "ToolRegistry"
      151     session_store: "SessionStore"
      152
      153     def register_tool(self, definition: dict, handler: Callable) -> None:
      154         self.registry.register(definition, handler)
      155
      156
      157 class AgentExtension(ABC):
      158     """业务扩展基类。子类实现 register()，可选覆盖钩子方法。"""
      159
      160     @abstractmethod
      161     def register(self, ctx: ExtensionContext) -> None:
      162         """服务启动时调用：向 registry 注册工具，做初始化配置。"""
      163
      164     def get_skill_prompt(self) -> str:
      165         """返回注入 system prompt 的技能描述文本块，默认空。"""
      166         return ""
      167
      168     def get_output_format_prompt(self) -> str:
      169         """返回输出格式说明，默认空（core 有通用默认格式）。"""
      170         return ""
      171
      172     def on_before_prompt(self, user_input: str, context: dict) -> str:
      173         """用户输入预处理（可注入额外上下文），默认透传。"""
      174         return user_input
      175
      176     def on_after_tool(self, name: str, args: dict, obs: str) -> str:
      177         """工具 observation 后处理（摘要/脱敏/压缩），默认透传。"""
      178         return obs
      179 ```
      180
      181 ---
      182
      183 ### 3.4 `backend/core/tool_utils.py`
      184
      185 ```python
      186 """通用工具校验辅助，从 backend/agent/tools.py 提取。"""
      187 import json
      188 from pathlib import Path
      189
      190
      191 def tool_error(msg: str) -> str:
      192     """返回标准错误 observation，模型可读并自行纠错。"""
      193     return json.dumps({"success": False, "error": msg}, ensure_ascii=False)
      194
      195
      196 def validate_file_path(path: str, tool_name: str) -> str | None:
      197     """文件不存在返回错误字符串，否则返回 None。"""
      198     if not path:
      199         return tool_error(f"[{tool_name}] 缺少 file_path，请先上传文件或在 context 中提供")
      200     if not Path(path).exists():
      201         return tool_error(f"[{tool_name}] 文件不存在: {path}，请确认路径是否正确")
      202     return None
      203 ```
      204
      205 ---
      206
      207 ### 3.5 `backend/core/agent.py`
      208
      209 ```python
      210 """
      211 CoreAgent — 纯 ReAct 引擎，不含任何业务逻辑。
      212 业务通过 AgentExtension 注入。
      213 """
      214 import asyncio
      215 import json
      216 import logging
      217 import re
      218 import types as _types
      219 from typing import Any, Callable, Dict, List, Optional, Tuple
      220
      221 from openai import OpenAI
      222
      223 from backend.core.registry import ToolRegistry
      224 from backend.core.extension import AgentExtension, ExtensionContext
      225 from backend.agent.session import SessionStore, get_session_store
      226
      227 logger = logging.getLogger(__name__)
      228
      229 TOOL_RESULT_MAX_CHARS = 16_000
      230 _CONTEXT_MAX_CHARS = 20_000       # 压缩阈值（原 40K，降低以更早压缩）
      231 _MAX_STEPS_HINT = "（已达最大步数）请根据目前已获取的信息直接给出最终回答，不再调用任何工具。"
      232 _CORE_OUTPUT_FORMAT = """\
      233 ## 输出格式（每轮必须）
      234 1. 先输出 <think>...</think>：目标 / 已知 / 缺失 / 本步行动。
      235 2. 若调用工具：紧接 tool_call；结果返回后目标已完成则直接输出最终回答；否则继续下一轮。
      236 3. 若不调用工具：在 <think> 后直接给出最终回答。
      237 **多轮指代**：用户说「选哪个」→ 必须调用 select_wanding_match；用户说「那个产品」→ 用上轮完整名称。"""
      238
      239
      240 def _extract_tag(content: str, tag: str) -> Tuple[str, str]:
      241     pattern = re.compile(rf"<{tag}>(.*?)</{tag}>", re.DOTALL | re.IGNORECASE)
      242     match = pattern.search(content)
      243     if not match:
      244         return content, ""
      245     return pattern.sub("", content).strip(), match.group(1).strip()
      246
      247
      248 def _trim_context(messages: List[dict], max_chars: int = _CONTEXT_MAX_CHARS) -> None:
      249     total = sum(len(str(m.get("content") or "")) for m in messages)
      250     if total <= max_chars:
      251         return
      252     for m in messages:
      253         if m.get("role") == "tool":
      254             orig = str(m.get("content") or "")
      255             if len(orig) > 200:
      256                 m["content"] = f"[已压缩，原长 {len(orig)} 字符]"
      257                 total -= len(orig) - len(m["content"])
      258                 if total <= max_chars:
      259                     break
      260
      261
      262 def _call_llm_streaming_sync(client, kwargs, on_token) -> Tuple[str, List, Optional[Dict]]:
      263     create_kw = {**kwargs, "stream": True, "stream_options": {"include_usage": True}}
      264     stream = client.chat.completions.create(**create_kw)
      265     content_parts: List[str] = []
      266     tool_calls_raw: Dict[int, dict] = {}
      267     last_usage = None
      268     for chunk in stream:
      269         if getattr(chunk, "usage", None):
      270             u = chunk.usage
      271             last_usage = {"prompt_tokens": u.prompt_tokens or 0, "completion_tokens": u.completion_tokens       
           or 0}
      272         if not chunk.choices:
      273             continue
      274         delta = chunk.choices[0].delta
      275         if delta.content:
      276             on_token(delta.content)
      277             content_parts.append(delta.content)
      278         if delta.tool_calls:
      279             for tc in delta.tool_calls:
      280                 idx = tc.index
      281                 if idx not in tool_calls_raw:
      282                     tool_calls_raw[idx] = {"id": getattr(tc, "id", "") or "", "name": "", "arguments": ""       
          }
      283                 fn = getattr(tc, "function", None)
      284                 if fn:
      285                     if fn.name: tool_calls_raw[idx]["name"] += fn.name
      286                     if fn.arguments: tool_calls_raw[idx]["arguments"] += fn.arguments
      287     content = "".join(content_parts)
      288     tool_calls = [
      289         _types.SimpleNamespace(
      290             id=tool_calls_raw[k]["id"],
      291             function=_types.SimpleNamespace(name=tool_calls_raw[k]["name"], arguments=tool_calls_raw[k]["       
          arguments"]),
      292         )
      293         for k in sorted(tool_calls_raw)
      294     ]
      295     return content, tool_calls, last_usage
      296
      297
      298 def _build_system_prompt(skill_prompt: str, output_format: str) -> str:
      299     return (
      300         "你是统一业务助手，**一个主 Agent 掌握全部技能**，根据用户意图直接选用下方工具完成目标。无子 Agen       
          t，不委托、不转发。\n\n"
      301         "---\n\n## 技能与工具（按目标选用）\n\n"
      302         + skill_prompt
      303         + "\n\n---\n\n"
      304         + (output_format or _CORE_OUTPUT_FORMAT)
      305     )
      306
      307
      308 class CoreAgent:
      309     def __init__(
      310         self,
      311         api_key: str,
      312         base_url: str,
      313         model: str,
      314         extensions: List[AgentExtension],
      315         session_store: Optional[SessionStore] = None,
      316     ):
      317         self.client = OpenAI(api_key=api_key, base_url=base_url)
      318         self.model = model
      319         self._extensions = extensions
      320
      321         if session_store is None:
      322             session_store = get_session_store()
      323         self._store = session_store
      324
      325         # 构建 Registry
      326         self._registry = ToolRegistry()
      327         ctx = ExtensionContext(registry=self._registry, session_store=self._store)
      328         skill_parts: List[str] = []
      329         output_fmt = ""
      330         for ext in extensions:
      331             ext.register(ctx)
      332             sp = ext.get_skill_prompt()
      333             if sp:
      334                 skill_parts.append(sp)
      335             of = ext.get_output_format_prompt()
      336             if of:
      337                 output_fmt = of  # 最后一个 extension 的格式优先
      338         self._system_prompt = _build_system_prompt("\n\n".join(skill_parts), output_fmt)
      339
      340     async def execute_react(
      341         self,
      342         user_input: str,
      343         context: Optional[Dict] = None,
      344         max_steps: int = 8,
      345         session_id: Optional[str] = None,
      346         on_token: Optional[Callable] = None,
      347         on_tool_start: Optional[Callable] = None,
      348         on_tool_calls_ready: Optional[Callable] = None,
      349         on_event: Optional[Callable] = None,
      350     ) -> Dict[str, Any]:
      351
      352         def _fire(event_type, payload):
      353             if on_event:
      354                 try: on_event(event_type, {"session_id": session_id or "", **payload})
      355                 except Exception: pass
      356
      357         _fire("loop_start", {"query": user_input[:200]})
      358
      359         # on_before_prompt 钩子
      360         user_content = user_input.strip()
      361         ctx = context or {}
      362         for ext in self._extensions:
      363             try: user_content = ext.on_before_prompt(user_content, ctx)
      364             except Exception: pass
      365
      366         if context and context.get("file_path"):
      367             user_content += f"\n\n[Context: 已上传报价单，file_path={context['file_path']}]"
      368
      369         if session_id and self._store:
      370             session = self._store.load(session_id)
      371             if context and context.get("file_path"):
      372                 session.file_path = context["file_path"]
      373             injection = self._store.build_injection(session)
      374             if injection:
      375                 user_content += f"\n\n{injection}"
      376
      377         tools = self._registry.get_definitions()
      378         messages: List[dict] = [
      379             {"role": "system", "content": self._system_prompt},
      380             {"role": "user", "content": user_content},
      381         ]
      382         thinking_parts: List[str] = []
      383         trace: List[dict] = []
      384         last_answer = ""
      385         last_usage = None
      386
      387         try:
      388             from backend.config import Config
      389             max_tokens = getattr(Config, "LLM_MAX_TOKENS", 5000)
      390         except Exception:
      391             max_tokens = 5000
      392
      393         for step in range(max_steps):
      394             is_last = step == max_steps - 1
      395             if is_last:
      396                 messages.append({"role": "user", "content": _MAX_STEPS_HINT})
      397
      398             kwargs: Dict[str, Any] = {"model": self.model, "messages": messages, "temperature": 0.1, "max       
          _tokens": max_tokens}
      399             if not is_last:
      400                 kwargs["tools"] = tools
      401                 kwargs["tool_choice"] = "auto"
      402
      403             step_usage = None
      404             if on_token is not None:
      405                 content, tool_calls, step_usage = await asyncio.to_thread(
      406                     _call_llm_streaming_sync, self.client, kwargs, on_token)
      407             else:
      408                 resp = self.client.chat.completions.create(**kwargs)
      409                 msg = resp.choices[0].message if resp.choices else None
      410                 if not msg: break
      411                 content = (msg.content or "").strip()
      412                 tool_calls = list(getattr(msg, "tool_calls", None) or [])
      413                 u = getattr(resp, "usage", None)
      414                 if u: step_usage = {"prompt_tokens": u.prompt_tokens or 0, "completion_tokens": u.complet       
          ion_tokens or 0}
      415             if step_usage:
      416                 last_usage = step_usage
      417
      418             content, thought = _extract_tag(content, "think")
      419             if thought:
      420                 thinking_parts.append(thought)
      421                 trace.append({"step": step + 1, "type": "thinking", "content": thought})
      422
      423             if not tool_calls:
      424                 if content:
      425                     last_answer = content
      426                     trace.append({"step": step + 1, "type": "response", "content": content})
      427                 break
      428
      429             tool_calls_for_msg = [
      430                 {"id": getattr(tc, "id", "") or f"call_{i}", "type": "function",
      431                  "function": {"name": getattr(tc.function, "name", ""), "arguments": getattr(tc.function,       
           "arguments", "{}") or "{}"}}
      432                 for i, tc in enumerate(tool_calls)
      433             ]
      434             messages.append({"role": "assistant", "content": content or None, "tool_calls": tool_calls_fo       
          r_msg})
      435
      436             n = len(tool_calls)
      437             if on_tool_calls_ready and n > 0:
      438                 try: on_tool_calls_ready(n)
      439                 except Exception: pass
      440
      441             for i, tc in enumerate(tool_calls):
      442                 name = getattr(tc.function, "name", "") or ""
      443                 if on_tool_start:
      444                     try: on_tool_start(name, i + 1, n)
      445                     except Exception: pass
      446                 try:
      447                     args = json.loads(getattr(tc.function, "arguments", "{}") or "{}")
      448                 except json.JSONDecodeError:
      449                     args = {}
      450
      451                 trace.append({"step": step + 1, "type": "tool_call", "name": name, "arguments": args})
      452                 obs = await self._registry.execute(name, args, ctx)
      453                 if len(obs) > TOOL_RESULT_MAX_CHARS:
      454                     obs = obs[:TOOL_RESULT_MAX_CHARS] + "\n…（已截断）"
      455
      456                 # on_after_tool 钩子
      457                 for ext in self._extensions:
      458                     try: obs = ext.on_after_tool(name, args, obs)
      459                     except Exception: pass
      460
      461                 trace.append({"step": step + 1, "type": "observation", "content": obs})
      462                 messages.append({"role": "tool", "tool_call_id": tool_calls_for_msg[i]["id"], "content":        
          obs})
      463
      464             _trim_context(messages)
      465
      466         # 澄清处理
      467         needs_clarification = False
      468         clarification_questions = None
      469         if last_answer and "needs_clarification" in last_answer:
      470             try:
      471                 d = json.loads(last_answer)
      472                 if d.get("needs_clarification"):
      473                     needs_clarification = True
      474                     clarification_questions = d.get("questions", [])
      475                     last_answer = "请补充说明：" + ("；".join(clarification_questions) if clarification_q       
          uestions else "您的意图不太明确。")
      476             except Exception:
      477                 pass
      478
      479         if session_id and self._store and last_answer:
      480             try:
      481                 self._store.save_turn(
      482                     session_id=session_id, query=user_input, agent="single", answer=last_answer,
      483                     file_path=ctx.get("file_path"),
      484                     input_tokens=last_usage.get("prompt_tokens") if last_usage else None,
      485                     output_tokens=last_usage.get("completion_tokens") if last_usage else None,
      486                 )
      487             except Exception as e:
      488                 logger.warning("Session save_turn failed: %s", e)
      489
      490         result = {"answer": last_answer or "", "thinking": "\n".join(thinking_parts) or None,
      491                   "trace": trace, "needs_clarification": needs_clarification,
      492                   "clarification_questions": clarification_questions, "error": None}
      493         _fire("loop_end", {k: v for k, v in result.items() if k != "error"})
      494         return result
      495 ```
      496
      497 ---
      498
      499 ### 3.6 `backend/plugins/__init__.py` 和 `backend/plugins/jagent/__init__.py`
      500
      501 ```python
      502 # 两个文件都是空文件，标记 package
      503 ```
      504
      505 ---
      506
      507 ### 3.7 `backend/plugins/jagent/skills.py`
      508
      509 ```python
      510 """
      511 JAgent 技能描述常量（从 backend/agent/agent.py 平移）。
      512 """
      513
      514 SKILL_INVENTORY_PRICE = """\
      515 **1. 库存与询价/价格**
      516 ..."""   # 直接从 backend/agent/agent.py 的 _SKILL_INVENTORY_PRICE 复制
      517
      518 SKILL_OOS = """\
      519 **2. 无货**
      520 ..."""   # 直接从 _SKILL_OOS 复制
      521
      522 SKILL_QUOTE = "..."  # _SKILL_QUOTE
      523 SKILL_FILL = "..."   # _SKILL_FILL
      524 SKILL_CLARIFY = "..." # _SKILL_CLARIFY
      525 SKILL_KNOWLEDGE = "..." # _SKILL_KNOWLEDGE
      526
      527 OUTPUT_FORMAT = """\
      528 ## 输出格式（每轮必须）
      529 ..."""    # _PROMPT_OUTPUT_FORMAT
      530
      531 ALL_SKILL_PROMPT = "\n\n".join([
      532     SKILL_INVENTORY_PRICE, SKILL_OOS, SKILL_QUOTE,
      533     SKILL_FILL, SKILL_CLARIFY, SKILL_KNOWLEDGE,
      534 ])
      535 ```
      536
      537 ---
      538
      539 ### 3.8 `backend/plugins/jagent/extension.py`
      540
      541 ```python
      542 """JAgentExtension — JAgent 业务插件，注册全部工具 + 技能 prompt。"""
      543 import asyncio
      544 import json
      545 import logging
      546 from typing import Any
      547
      548 from backend.core.extension import AgentExtension, ExtensionContext
      549 from backend.plugins.jagent.skills import ALL_SKILL_PROMPT, OUTPUT_FORMAT
      550
      551 logger = logging.getLogger(__name__)
      552
      553 _VALID_CUSTOMER_LEVELS = {"A", "B", "C", "D"}
      554 _INVENTORY_TOOLS = {
      555     "search_inventory", "get_inventory_by_code", "match_quotation",
      556     "match_by_quotation_history", "match_wanding_price", "select_wanding_match",
      557 }
      558
      559
      560 class JAgentExtension(AgentExtension):
      561
      562     def get_skill_prompt(self) -> str:
      563         return ALL_SKILL_PROMPT
      564
      565     def get_output_format_prompt(self) -> str:
      566         return OUTPUT_FORMAT
      567
      568     def on_after_tool(self, name: str, args: dict, obs: str) -> str:
      569         """大结果压缩：run_quotation_fill 超过 3000 字时截取前 5 条 items。"""
      570         if name == "run_quotation_fill" and len(obs) > 3000:
      571             try:
      572                 data = json.loads(obs)
      573                 items = data.get("items", [])
      574                 if len(items) > 5:
      575                     data["items"] = items[:5]
      576                     data["_truncated"] = f"共 {len(items)} 条，已截至前 5 条"
      577                     return json.dumps(data, ensure_ascii=False)
      578             except Exception:
      579                 pass
      580         return obs
      581
      582     def register(self, ctx: ExtensionContext) -> None:
      583         self._register_oos_tools(ctx)
      584         self._register_inventory_tools(ctx)
      585         self._register_quote_tools(ctx)
      586         self._register_extra_tools(ctx)
      587
      588     # ------------------------------------------------------------------ OOS
      589
      590     def _register_oos_tools(self, ctx: ExtensionContext) -> None:
      591         from backend.agent.tools import (
      592             _run_oos_list, _run_oos_stats, _run_oos_by_file, _run_oos_by_time,
      593         )
      594
      595         ctx.register_tool(
      596             {"type": "function", "function": {
      597                 "name": "get_oos_list",
      598                 "description": "【无货】获取无货产品列表，含被报无货次数与邮件发送状态。",
      599                 "parameters": {"type": "object", "properties": {
      600                     "limit": {"type": "integer", "description": "最多返回条数，默认 100"}
      601                 }, "required": []},
      602             }},
      603             lambda args, ctx_: asyncio.to_thread(_run_oos_list, args.get("limit", 100))
      604                 .then(lambda out: out.get("result", "") if out.get("success") else json.dumps(out, ensure       
          _ascii=False))
      605             if False else self._make_oos_handler(_run_oos_list, "limit", 100),
      606         )
      607         # 注：为可读性，实际实现用 _make_sync_handler 包装（见下方辅助）
      608
      609         ctx.register_tool(
      610             {"type": "function", "function": {"name": "get_oos_stats",
      611              "description": "【无货】获取无货统计。",
      612              "parameters": {"type": "object", "properties": {}}}},
      613             self._make_simple_handler(_run_oos_stats),
      614         )
      615
      616         ctx.register_tool(
      617             {"type": "function", "function": {"name": "get_oos_by_file",
      618              "description": "【无货】按文件统计无货。",
      619              "parameters": {"type": "object", "properties": {
      620                  "limit": {"type": "integer", "description": "最多展示文件数，默认 50"}
      621              }, "required": []}}},
      622             self._make_oos_handler(_run_oos_by_file, "limit", 50),
      623         )
      624
      625         ctx.register_tool(
      626             {"type": "function", "function": {"name": "get_oos_by_time",
      627              "description": "【无货】按时间统计无货。",
      628              "parameters": {"type": "object", "properties": {
      629                  "last_n_days": {"type": "integer", "description": "统计最近几天，默认 30"}
      630              }, "required": []}}},
      631             self._make_oos_handler(_run_oos_by_time, "last_n_days", 30),
      632         )
      633
      634         # register_oos, register_oos_from_text — 直接用 tools.py 现有实现
      635         from backend.agent.tools import EXTRA_TOOLS, execute_tool as _old_execute
      636         for t in EXTRA_TOOLS:
      637             n = t["function"]["name"]
      638             if n in ("register_oos", "register_oos_from_text",
      639                      "run_quotation_fill", "ask_clarification", "append_business_knowledge"):
      640                 ctx.register_tool(t, self._make_legacy_handler(n, _old_execute))
      641
      642     def _make_oos_handler(self, fn, arg_name, default):
      643         async def handler(args, context):
      644             val = args.get(arg_name, default)
      645             try: val = int(val)
      646             except (TypeError, ValueError): val = default
      647             out = await asyncio.to_thread(fn, val)
      648             return out.get("result", "") if out.get("success") else json.dumps(out, ensure_ascii=False)
      649         return handler
      650
      651     def _make_simple_handler(self, fn):
      652         async def handler(args, context):
      653             out = await asyncio.to_thread(fn)
      654             return out.get("result", "") if out.get("success") else json.dumps(out, ensure_ascii=False)
      655         return handler
      656
      657     def _make_legacy_handler(self, name: str, old_execute):
      658         """临时桥接：继续调用旧的 execute_tool 分发（迁移期过渡）。"""
      659         async def handler(args, context):
      660             return await old_execute(name, args, context)
      661         return handler
      662
      663     # ---------------------------------------------------------- 库存工具
      664
      665     def _register_inventory_tools(self, ctx: ExtensionContext) -> None:
      666         from backend.tools.inventory.services.inventory_agent_tools import (
      667             get_inventory_tools_openai_format,
      668         )
      669         for tool_def in get_inventory_tools_openai_format():
      670             name = tool_def["function"]["name"]
      671             ctx.register_tool(tool_def, self._make_inventory_handler(name))
      672
      673     def _make_inventory_handler(self, name: str):
      674         async def handler(args: dict, context: dict) -> str:
      675             from backend.tools.inventory.services.inventory_agent_tools import (
      676                 execute_inventory_tool, config as inv_config,
      677             )
      678             timeout_sec = getattr(inv_config, "TOOL_EXEC_TIMEOUT", 35)
      679             try:
      680                 out = await asyncio.wait_for(
      681                     asyncio.to_thread(execute_inventory_tool, name, args),
      682                     timeout=timeout_sec,
      683                 )
      684                 return out.get("result", "") if out.get("success") else json.dumps(out, ensure_ascii=Fals       
          e)
      685             except asyncio.TimeoutError:
      686                 return json.dumps({"success": False, "error": f"工具执行超时（{timeout_sec}s）"}, ensure_       
          ascii=False)
      687         return handler
      688
      689     # ---------------------------------------------------------- 报价单工具
      690
      691     def _register_quote_tools(self, ctx: ExtensionContext) -> None:
      692         from backend.tools.quotation.quote_tools import get_quote_tools_openai_format
      693         from backend.core.tool_utils import validate_file_path
      694         _QUOTE_WITH_FILE = {"extract_quotation_data", "fill_quotation_sheet", "parse_excel_smart", "edit_       
          excel"}
      695
      696         for tool_def in get_quote_tools_openai_format():
      697             name = tool_def["function"]["name"]
      698             need_file = name in _QUOTE_WITH_FILE
      699             ctx.register_tool(tool_def, self._make_quote_handler(name, need_file))
      700
      701     def _make_quote_handler(self, name: str, need_file: bool):
      702         from backend.core.tool_utils import validate_file_path
      703         async def handler(args: dict, context: dict) -> str:
      704             if need_file:
      705                 fp = (args.get("file_path") or "").strip() or (context.get("file_path") or "").strip()
      706                 err = validate_file_path(fp, name)
      707                 if err: return err
      708             from backend.tools.quotation.quote_tools import execute_quote_tool
      709             out = await asyncio.to_thread(execute_quote_tool, name, args)
      710             if out.get("success"):
      711                 return out.get("result", "") or json.dumps({k: v for k, v in out.items() if k != "success       
          "}, ensure_ascii=False)
      712             return json.dumps(out, ensure_ascii=False)
      713         return handler
      714
      715     # ---------------------------------------------------------- 额外工具（已通过 legacy handler 注册）
      716
      717     def _register_extra_tools(self, ctx: ExtensionContext) -> None:
      718         pass  # ask_clarification, append_business_knowledge, register_oos* 已在 _register_oos_tools 里注       
          册
      719 ```
      720
      721 ---
      722
      723 ## 四、修改文件（diff 说明）
      724
      725 ### 4.1 `backend/agent/agent.py` → 薄封装
      726
      727 **改动**：删掉全部业务常量和 `_build_system_prompt`，只保留向后兼容的 `SingleAgent` 别名。
      728
      729 ```python
      730 # backend/agent/agent.py — 改造后仅剩这几行
      731 """
      732 向后兼容层。业务逻辑已迁移至 backend/core/agent.py + backend/plugins/jagent。
      733 """
      734 from backend.core.agent import CoreAgent
      735 from backend.config import Config
      736 from backend.plugins.jagent.extension import JAgentExtension
      737
      738 # 兼容旧 import: from backend.agent.agent import SingleAgent
      739 class SingleAgent(CoreAgent):
      740     def __init__(self, api_key=None, base_url=None, model=None, session_store=None):
      741         super().__init__(
      742             api_key=api_key or Config.OPENAI_API_KEY,
      743             base_url=base_url or Config.OPENAI_BASE_URL,
      744             model=model or Config.LLM_MODEL,
      745             extensions=[JAgentExtension()],
      746             session_store=session_store,
      747         )
      748 ```
      749
      750 ### 4.2 `backend/agent/tools.py` → 保留实现，删分发链
      751
      752 **改动**：
      753 - 保留 `_run_oos_list`, `_run_oos_stats`, `_run_oos_by_file`, `_run_oos_by_time`（JAgentExtension 要引用        
          ）
      754 - 保留 `EXTRA_TOOLS`（JAgentExtension 过渡期引用）
      755 - 删掉 `execute_tool()`（分发逻辑迁移到 Registry）
      756 - 删掉 `get_all_tools()`（迁移到 JAgentExtension.register）
      757
      758 ### 4.3 `backend/server/api/app.py` — agent 通过 app.state 共享
      759
      760 ```python
      761 # startup_event 内：
      762 from backend.core.agent import CoreAgent
      763 from backend.plugins.jagent.extension import JAgentExtension
      764 from backend.config import Config
      765
      766 agent = CoreAgent(
      767     api_key=Config.OPENAI_API_KEY,
      768     base_url=Config.OPENAI_BASE_URL,
      769     model=Config.LLM_MODEL,
      770     extensions=[JAgentExtension()],
      771 )
      772 app.state.agent = agent
      773 ```
      774
      775 ### 4.4 `backend/server/api/routes.py` — 从 app.state 取 agent
      776
      777 ```python
      778 # 删掉模块级 single_agent = SingleAgent(...)
      779 # 路由函数里改为：
      780 from fastapi import Request
      781 @router.post("/api/query")
      782 async def query(request: Request, body: dict = Body(...)):
      783     agent = request.app.state.agent
      784     ...
      785 ```
      786
      787 ### 4.5 `backend/server/gateway/handlers/chat.py` — 同样从 app.state 取
      788
      789 ```python
      790 # 删掉 _single_agent 全局变量
      791 # 在 chat_send handler 里：
      792 from starlette.websockets import WebSocket
      793 agent = websocket.app.state.agent
      794 ```
      795
      796 ---
      797
      798 ## 五、六步执行顺序
      799
      800 ```
      801 Step 1  新建 core/ 四个文件（零风险，不改现有代码）
      802         验证：python -c "from backend.core.agent import CoreAgent; print('ok')"
      803
      804 Step 2  新建 plugins/jagent/ 两个文件（技能 prompt 平移 + Extension 骨架）
      805         验证：python -c "from backend.plugins.jagent.extension import JAgentExtension; print(JAgentExtens       
          ion().get_skill_prompt()[:50])"
      806
      807 Step 3  修改 backend/agent/agent.py → 薄封装（SingleAgent 变 CoreAgent 的子类）
      808         验证：python run_backend.py  → 正常启动，所有接口可用
      809
      810 Step 4  app.py 改为 app.state.agent；routes.py / chat.py 从 app.state 取
      811         验证：启动 → 发一条消息 → 检查工具调用是否正常
      812
      813 Step 5  JAgentExtension.register() 逐步完善（先 legacy handler 过渡，再逐个替换）
      814         验证：每次替换一类工具后，手测该类工具（库存 → OOS → 报价单）
      815
      816 Step 6  清理：删除 backend/agent/tools.py 中的 execute_tool 分发链（~150行）
      817               删除 backend/agent/agent.py 中的 _SKILL_* 常量
      818         验证：启动 + 全链路回归测试
      819 ```
      820
      821 ---
      822
      823 ## 六、回退方案
      824
      825 - 每步改动前 `git commit` 一次，失败直接 `git reset --hard`
      826 - Step 3（SingleAgent 薄封装）是关键节点：只要 `SingleAgent.__init__` 参数签名不变，`routes.py` / `chat.p       
          y` 不需要同步改
      827 - 实在来不及迁移时，`backend/agent/agent.py` 旧实现可以通过条件 import 保留
      828
      829 ---
      830
      831 ## 七、改造后启动新业务只需
      832
      833 ```python
      834 # plugins/hr_bot/extension.py
      835 from backend.core.extension import AgentExtension, ExtensionContext
      836
      837 class HRBotExtension(AgentExtension):
      838     def get_skill_prompt(self): return "你是 HR 助手，掌握员工查询、薪酬查询工具..."
      839     def register(self, ctx):
      840         ctx.register_tool(EMPLOYEE_TOOL_DEF, self._handle_employee)
      841         ctx.register_tool(SALARY_TOOL_DEF, self._handle_salary)
      842     async def _handle_employee(self, args, ctx): ...
      843     async def _handle_salary(self, args, ctx): ...
      844
      845 # main.py
      846 app = create_app(extensions=[HRBotExtension()])
      847 ```