# 数据段截取逻辑示例（get_data_section）

## 核心逻辑

三层策略取**更早的结束行**：
1. **结构断裂检测**：非空列数骤降 或 连续空行
2. **关键词检测**：出现表尾关键词（银行、条款等）
3. **最小行数保护** + **行数上限**

最终：`df.iloc[header_idx : end_idx]`（不包含 end_idx）

---

## 示例 1：标准表格（关键词截断）

```
行号 | 内容
-----|------------------------------------------
0    | [标题行] 国际集团报价单
1    | [空行]
2    | [表头] 产品名称 | 规格 | 单位 | 数量 | 产品编号 | 单价
3    | 盲板      | DN100 | 个   | 1    | 无货     | 100
4    | 法兰      | DN125 | 个   | 3    | 801007   | 200
5    | 大小头    | DN80  | 个   | 2    | 无货     | 150
6    | [空行]
7    | 含税总价：5000元
8    | 银行：中国银行
9    | 账号：123456789
10   | TERMS & CONDITION
```

**处理过程：**
- **找表头**：行 2（含“产品名称/单位/数量”）
- **第一层（结构）**：行 3-5 非空列数 = 6，行 6 空行但行 7 非空，行 7 非空列数 = 2（< 6*0.35=2.1），但至少 2 列，所以行 7 不算断裂 → 继续扫到行 8
- **第二层（关键词）**：行 7 含“含税总价”（FOOTER_KEYWORDS）→ `end_by_keyword = 7`
- **取 min**：`end_idx = min(end_by_structure, end_by_keyword) = min(8, 7) = 7`
- **最小行数**：已命中关键词，不触发保护
- **行数上限**：假设 MAX_TABLE_ROWS=500，不限制
- **结果**：`df.iloc[2:7]` = 行 2-6（表头 + 3 行数据 + 1 空行）

**送 LLM**：行 2（表头）+ 行 3-6（数据，含 2 行无货）

---

## 示例 2：结构断裂（列数骤降）

```
行号 | 内容
-----|------------------------------------------
0    | [标题] 报价单
1    | [表头] 产品名称 | 规格 | 单位 | 数量 | 产品编号
2    | 盲板      | DN100 | 个   | 1    | 无货
3    | 法兰      | DN125 | 个   | 3    | 801007
4    | 大小头    | DN80  | 个   | 2    | 无货
5    | [空行]
6    | [空行]
7    | 发货地址：北京市
8    | 银行：中国银行
```

**处理过程：**
- **找表头**：行 1
- **第一层（结构）**：
  - 表头行 1 非空列数 = 5
  - 行 2-4 非空列数 = 5 → `expected_cols = 5`，`threshold = max(2, 5*0.35) = max(2, 1.75) = 2`
  - 行 5 空行，行 6 也空行 → `end_by_structure = 5`（连续空行）
- **第二层（关键词）**：行 7 含“发货地址”（FOOTER_KEYWORDS）→ `end_by_keyword = 7`
- **取 min**：`end_idx = min(5, 7) = 5`
- **最小行数**：未命中关键词（end_by_keyword=7 < len(df)=9），但 `end_idx - header_idx = 5 - 1 = 4 < 20`，触发保护 → `end_idx = min(1+20, 9) = 9`（但实际会受行数上限限制）
- **行数上限**：假设 MAX=500，不限制 → `end_idx = 9`
- **结果**：`df.iloc[1:9]` = 行 1-8（表头 + 3 行数据 + 2 空行 + 发货地址 + 银行）

**说明**：连续空行触发了结构断裂，但最小行数保护又拉回了更多行。实际场景中，如果表尾关键词在行 7，最终会以关键词为准（min(5, 7) = 5，但最小行数保护会再拉长）。

---

## 示例 3：最小行数保护生效（避免只送 3 行）

```
行号 | 内容
-----|------------------------------------------
0    | [标题] 报价单
1    | [表头] 产品名称 | 规格 | 单位 | 数量
2    | 盲板      | DN100 | 个   | 1
3    | 法兰      | DN125 | 个   | 3
4    | [空行]
5    | [空行]
6    | 大小头    | DN80  | 个   | 2    | 无货
7    | 三角阀    | DN50  | 个   | 5    | 无货
...  | ...（共 28 行）
28   | 其他产品...
```

**处理过程：**
- **找表头**：行 1
- **第一层（结构）**：行 4-5 连续空行 → `end_by_structure = 4`
- **第二层（关键词）**：未命中任何表尾关键词 → `end_by_keyword = 28`（整表长度）
- **取 min**：`end_idx = min(4, 28) = 4`
- **最小行数保护**：`end_by_keyword >= len(df)`（未命中关键词）且 `end_idx - header_idx = 4 - 1 = 3 < 20` → **触发保护** → `end_idx = min(1+20, 28) = 20`
- **行数上限**：假设 MAX=500，不限制
- **结果**：`df.iloc[1:20]` = 行 1-19（至少 20 行，包含后面的无货行 6-7）

**说明**：如果没有最小行数保护，会只送 3 行（表头+2 数据），漏掉后面的无货行。保护机制确保至少送 20 行。

---

## 示例 4：行数上限生效（大表截断）

```
行号 | 内容
-----|------------------------------------------
0    | [表头] 产品名称 | 规格 | 单位 | 数量 | 产品编号
1    | 产品1   | ... | 个   | 10   | 001
2    | 产品2   | ... | 个   | 20   | 002
...  | ...（共 1000 行数据，无表尾关键词）
1000 | 产品1000| ... | 个   | 5    | 无货
```

**处理过程：**
- **找表头**：行 0
- **第一层（结构）**：无断裂 → `end_by_structure = 1000`
- **第二层（关键词）**：未命中 → `end_by_keyword = 1000`
- **取 min**：`end_idx = min(1000, 1000) = 1000`
- **最小行数**：`end_idx - header_idx = 1000 - 0 = 1000 >= 20`，不触发
- **行数上限**：假设 `MAX_TABLE_ROWS_FOR_LLM = 500` → `end_idx = min(1000, 0+500) = 500`
- **结果**：`df.iloc[0:500]` = 行 0-499（只送前 500 行）

**说明**：大表会被行数上限截断，避免 token 超限。如果无货行在 500 行之后，会被漏掉（需要调大 MAX_TABLE_ROWS_FOR_LLM 或设为 0）。

---

## 示例 5：关键词早于结构断裂（关键词优先）

```
行号 | 内容
-----|------------------------------------------
0    | [表头] 产品名称 | 规格 | 单位 | 数量 | 产品编号
1    | 盲板      | DN100 | 个   | 1    | 无货
2    | 法兰      | DN125 | 个   | 3    | 801007
3    | 含税总价：5000元
4    | [空行]
5    | [空行]
6    | 其他说明...
```

**处理过程：**
- **找表头**：行 0
- **第一层（结构）**：行 4-5 连续空行 → `end_by_structure = 4`
- **第二层（关键词）**：行 3 含“含税总价” → `end_by_keyword = 3`
- **取 min**：`end_idx = min(4, 3) = 3`（关键词更早，优先）
- **结果**：`df.iloc[0:3]` = 行 0-2（表头 + 2 行数据，不含“含税总价”行）

**说明**：关键词检测优先于结构断裂，确保表尾信息不被送进 LLM。

---

## 示例 6：多层保护叠加

```
行号 | 内容
-----|------------------------------------------
0    | [表头] 产品名称 | 规格 | 单位 | 数量
1    | 产品1   | ... | 个   | 1
2    | [空行]
3    | [空行]
4    | 产品2   | ... | 个   | 2    | 无货
...  | ...（共 30 行，无表尾关键词）
30   | 产品30  | ... | 个   | 30
```

**处理过程：**
- **找表头**：行 0
- **第一层（结构）**：行 2-3 连续空行 → `end_by_structure = 2`
- **第二层（关键词）**：未命中 → `end_by_keyword = 30`
- **取 min**：`end_idx = min(2, 30) = 2`
- **最小行数保护**：未命中关键词 且 `2 - 0 = 2 < 20` → **触发** → `end_idx = min(0+20, 30) = 20`
- **行数上限**：假设 MAX=500，不限制 → `end_idx = 20`
- **结果**：`df.iloc[0:20]` = 行 0-19（至少 20 行，包含无货行 4）

**说明**：结构断裂想截到行 2，但最小行数保护拉回 20 行，确保不遗漏后续无货行。

---

## 关键参数

- **threshold = max(2, expected_cols * 0.35)**：非空列数低于此视为断裂（至少 2 列）
- **MIN_DATA_SECTION_ROWS = 20**：最小数据行保护（仅当未命中表尾关键词时生效）
- **MAX_TABLE_ROWS_FOR_LLM = 500**：行数上限兜底（0=不限制）

---

## 调试建议

在 `processor.py` 的日志里可以看到：
```
Sheet '询价单': total_rows=113, rows_sent=100, has_wu_huo=True, mode=full_table
```

- `total_rows`：整表行数
- `rows_sent`：实际送 LLM 的行数（`len(data_section)`）
- 若 `rows_sent < total_rows` 且 `has_wu_huo=False`，可能是数据段截断过早，无货行在后续行里
